# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module Moov
  module Models
    module Components
    
      # Defines the specific parameters used for fee calculation.
      class FeeProperties
        extend T::Sig
        include Crystalline::MetadataFields

        # Defines the volume ranges for tiered pricing models.
        field :volume_ranges, Crystalline::Array.new(Models::Components::VolumeRange), { 'format_json': { 'letter_case': ::Moov::Utils.field_name('volumeRanges'), required: true } }
        # A fixed fee that is applied to the amount of each transaction in the `fixed` and `blended` fee models.
        field :fixed_amount, Crystalline::Nilable.new(Models::Components::AmountDecimal), { 'format_json': { 'letter_case': ::Moov::Utils.field_name('fixedAmount') } }
        # A percentage fee that is applied to the amount of each transaction in the `blended` fee model, expressed as a decimal. 
        # 
        # For example, 0.05% is '0.05'.
        field :variable_rate, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Moov::Utils.field_name('variableRate') } }
        # Specifies the minimum allowable spending for a single transaction, working as a transaction floor.
        field :min_per_transaction, Crystalline::Nilable.new(Models::Components::AmountDecimal), { 'format_json': { 'letter_case': ::Moov::Utils.field_name('minPerTransaction') } }
        # Specifies the maximum allowable spending for a single transaction, working as a transaction ceiling.
        field :max_per_transaction, Crystalline::Nilable.new(Models::Components::AmountDecimal), { 'format_json': { 'letter_case': ::Moov::Utils.field_name('maxPerTransaction') } }

        sig { params(volume_ranges: T::Array[Models::Components::VolumeRange], fixed_amount: T.nilable(Models::Components::AmountDecimal), variable_rate: T.nilable(::String), min_per_transaction: T.nilable(Models::Components::AmountDecimal), max_per_transaction: T.nilable(Models::Components::AmountDecimal)).void }
        def initialize(volume_ranges:, fixed_amount: nil, variable_rate: nil, min_per_transaction: nil, max_per_transaction: nil)
          @volume_ranges = volume_ranges
          @fixed_amount = fixed_amount
          @variable_rate = variable_rate
          @min_per_transaction = min_per_transaction
          @max_per_transaction = max_per_transaction
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @volume_ranges == other.volume_ranges
          return false unless @fixed_amount == other.fixed_amount
          return false unless @variable_rate == other.variable_rate
          return false unless @min_per_transaction == other.min_per_transaction
          return false unless @max_per_transaction == other.max_per_transaction
          true
        end
      end
    end
  end
end
